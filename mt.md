### 有一个长为n的数组A，求满足0≤a≤b<n的A[b]-A[a]的最大值。给定数组A及它的大小n，请返回最大差值。

```
import java.util.*;  
  
public class LongestDistance {  
    public int getDis(int[] A, int n) {  
        // write code here  
        int result = 0;  
        int min = A[0];  
        if (n > 1) {  
            for (int i = 1; i < n; i++) {  
                if (A[i] - min > result) {  
                    result = A[i] - min;  
                }  
                if (A[i] < min) {  
                    min = A[i];  
                }  
            }  
        }  
        return result;  
    }  
}  
```


### 在4x4的棋盘上摆满了黑白棋子，黑白两色的位置和数目随机其中左上角坐标为(1,1),右下角坐标为(4,4),现在依次有一些翻转操作，要对一些给定支点坐标为中心的上下左右四个棋子的颜色进行翻转，请计算出翻转后的棋盘颜色。给定两个数组A和f,分别为初始棋盘和翻转位置。其中翻转位置共有3个。请返回翻转后的棋盘。


```
import java.util.*;

public class Flip {
    
    public int[][] flipChess(int[][] A, int[][] f) {
        // write code here
        for(int i=0;i<f.length;i++)
        {
            int m=f[i][0]-1;
            int n=f[i][1]-1;
            change(A,m-1,n);
            change(A,m+1,n);
            change(A,m,n-1);
            change(A,m,n+1);
        }
        return A;
    }
    public static void change(int A[][],int m,int n)
    {
        if(m<0||n<0||m==A.length||n==A[0].length)
        {
            return;
        }
        A[m][n]=A[m][n]==0?1:0;
        
    }
    
}
```


### 现在有一个城市销售经理，需要从公司出发，去拜访市内的商家，已知他的位置以及商家的位置，但是由于城市道路交通的原因，他只能在左右中选择一个方向，在上下中选择一个方向，现在问他有多少种方案到达商家地址。给定一个地图map及它的长宽n和m，其中1代表经理位置，2代表商家位置，-1代表不能经过的地区，0代表可以经过的地区，请返回方案数，保证一定存在合法路径。保证矩阵的长宽都小于等于10。

```
public int countPath(int[][] map, int n, int m) {
????// 首先找出1和2所在的位置
????int i,j;
????int x1=0,x2 = 0,y1 = 0,y2 = 0;
????for (i = 0; i < n; i++) {
????????for (j = 0; j < m; j++) {
????????????if(map[i][j]==1){
????????????????x1 = i;y1=j;
????????????}else if(map[i][j]==2){
????????????????x2=i;y2=j;
????????????}
????????}
????}??????
????if(x1==x2&&y1==y2){// 两点重合
????????return 1;
????}
????if(x1>x2){// x1,y1用于保存行下标的较小者
????????x1 = x1^x2^(x2=x1);
????????y1 = y1^y2^(y2=y1);
????}
????int dp[][] = new int[n][m];
????if(y1<y2){// 两点处在主对角线上
????????dp[x1][y1] = 1;
????????for (i = x1+1; i<=x2; i++) {
????????????dp[i][y1] = map[i][y1]==-1?0:dp[i-1][y1];
????????}
????????for (j = y1+1; j <=y2; j++) {
????????????dp[x1][j] = map[x1][j]==-1?0:dp[x1][j-1];
????????}
????????for (i = x1+1; i <= x2; i++) {
????????????for (j = y1+1; j <=y2; j++) {
????????????????dp[i][j] = map[i][j]==-1?0:dp[i-1][j]+dp[i][j-1];
????????????}
????????}
????}else{// 两者处在副对角线上
????????dp[x1][y1] = 1;
????????for (i = x1+1; i<=x2; i++) {
????????????dp[i][y1] = map[i][y1]==-1?0:dp[i-1][y1];
????????}
????????for (j = y1-1; j >=y2; j--) {
????????????dp[x1][j] = map[x1][j]==-1?0:dp[x1][j+1];
????????}
????????for (i = x1+1; i <= x2; i++) {
????????????for (j = y1-1; j >=y2; j--) {
????????????????dp[i][j] = map[i][j]==-1?0:dp[i-1][j]+dp[i][j+1];
????????????}
????????}
????}
????return dp[x2][y2];
}
```